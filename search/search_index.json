{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to STEM3","text":""},{"location":"#welcome-to-stem3","title":"Welcome to STEM3","text":"<p>This is the documentation for the STEM3 course. Here you will find all the necessary information, schedules, and resources to help you succeed in the course.</p>"},{"location":"#course-language","title":"Course language","text":"<p>The course will be conducted in English. All materials, lectures, and communications will be in English and also all students are expected to participate in English.</p>"},{"location":"#course-overview","title":"Course overview","text":"<p>Start date: November 13, 2025  </p> <p>End date: December 03, 2025</p> <p>Instructors: Prof. Dr. Ruxandra Lasowski and Prof. Dr. Uwe Hahne</p> <p>Location: HFU Campus Furtwangen, M-Bau, Room M0.07</p> <p>See STEM3 Course Schedule for the detailed course schedule.</p>"},{"location":"course-schedule/","title":"STEM3 Course Schedule","text":""},{"location":"course-schedule/#stem3-course-schedule","title":"STEM3 Course Schedule","text":""},{"location":"course-schedule/#thu-nov-13th-2025","title":"Thu, Nov 13th 2025","text":"<p>Start: 14:00 End: 17:30</p> <p>Content:</p> <ul> <li>Expectation/Experience</li> <li>Schedule and Grading</li> <li>Theory</li> <li>Visualization task</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"course-schedule/#fri-nov-14th-2025","title":"Fri, Nov 14th 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Visualization task (presentation)</li> <li>Fantasy device (start)</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"course-schedule/#mon-nov-17th-2025","title":"Mon, Nov 17th 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Fantasy device (presentation)</li> <li>Real ESP32 devices</li> </ul> <p>Details:</p> <ul> <li>Hello world ESP32</li> <li>Output control with ESP32</li> <li>Touch input with ESP32</li> <li>Controlling an LED with touch input</li> </ul>"},{"location":"course-schedule/#tue-nov-18th-2025","title":"Tue, Nov 18th 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>First tasks with ESP32: Combining ESP32 with computer, mini project camera booth (OpenCV)</li> </ul> <p>Details:</p> <ul> <li>Touch input to capture images --&gt; this is an exemplary project for combining ESP32 with computer via Serial communication.</li> <li>The first task is to build a controller using the ESP32. It should handle at least five different touch inputs and send signals to a PC via Serial communication. On the PC side, a simple Python program should read the serial input and display the received signals in the console. Implement a small game that uses the touch inputs to control a character or object on the screen.</li> </ul>"},{"location":"course-schedule/#wed-nov-19th-2025","title":"Wed, Nov 19th 2025","text":"<p>Start: 9:00 End: 13:00</p> <p>Content:</p> <ul> <li>Working on and demoing first ESP32 task</li> </ul> <p>Details:</p> <ul> <li>Highschool students will visit the lab and see the ESP32 projects. Use them for user testing and feedback.</li> </ul>"},{"location":"course-schedule/#thu-nov-20th-2025","title":"Thu, Nov 20th 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Finishing and presenting ESP32 tasks</li> </ul> <p>Details:</p> <ul> <li>If you have not finished the first ESP32 task, use the morning to complete it.</li> <li>In the afternoon (2:15pm), present your ESP32 projects to the class. Each person gets 5 minutes to showcase their work and explain their learning process.</li> <li>Note that not just the presentations are judged, but also your curiosity about the other projects and your engagement during the presentations.</li> </ul>"},{"location":"course-schedule/#fri-nov-21st-2025","title":"Fri, Nov 21st 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Working with Robots</li> </ul> <p>Details:</p> <ul> <li>GoPiGo</li> </ul>"},{"location":"course-schedule/#mon-nov-24th-2025","title":"Mon, Nov 24th 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Working with Robots</li> </ul> <p>Details:</p> <ul> <li>GoPiGo</li> </ul>"},{"location":"course-schedule/#tue-nov-25th-2025","title":"Tue, Nov 25th 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Theory image processing</li> <li>OpenCV tutorials</li> </ul> <p>Details:</p> <ul> <li>OpenCV</li> <li>Image processing theory: Slides</li> </ul>"},{"location":"course-schedule/#wed-nov-26th-2025","title":"Wed, Nov 26th 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>OpenCV development</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"course-schedule/#thu-nov-27th-2025","title":"Thu, Nov 27th 2025","text":"<p>Start: 14:00 End: 17:00</p> <p>Content:</p> <p>Project planning:</p> <ul> <li>Build pairs for mini-project, brainstorm ideas, plan implementation</li> <li>Each mini-project should combine:</li> <li>Camera image processing via OpenCV or using another input sensor (not just button or touch)</li> <li>ESP32 or Robot interaction as output device</li> <li>Optional: Human pose estimation or other advanced techniques</li> <li>Clarify requirements, needed hardware and goals for mini-project</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"course-schedule/#fri-nov-28th-2025","title":"Fri, Nov 28th 2025","text":"<p>Start: 9:30 End: 17:00</p> <p>Content:</p> <ul> <li>Working on the Mini-Project</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"course-schedule/#mon-dec-1st-2025","title":"Mon, Dec 1st 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Working on the Mini-Project</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"course-schedule/#tue-dec-2nd-2025","title":"Tue, Dec 2nd 2025","text":"<p>Start: 9:00 End: 17:00</p> <p>Content:</p> <ul> <li>Working on the Mini-Project</li> <li>Final presentation preparation</li> <li>Final presentations starting at 3 pm (presence is mandatory for all, not just presenters)</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"course-schedule/#wed-dec-3rd-2025","title":"Wed, Dec 3rd 2025","text":"<p>Start: 9:00 End: 11:00</p> <p>Content:</p> <ul> <li>Final presentations continued (presence is mandatory for all, not just presenters)</li> </ul> <p>Details:</p> <ul> <li>tbd</li> </ul>"},{"location":"administration/administration/","title":"Administration","text":""},{"location":"administration/administration/#administration","title":"Administration","text":""},{"location":"administration/administration/#course-objectives","title":"Course objectives","text":"<p>The STEM3 course aims to provide students with a comprehensive understanding of physical computing, focusing on the integration of hardware and software to create interactive systems as well as camera image processing. The goal is to reduce the barriers between the physical and digital worlds, enabling students to design and implement games and immersive media projects that respond to real-world stimuli.</p>"},{"location":"administration/administration/#course-structure","title":"Course structure","text":"<p>The course follows the for GMB usual structure of full day workshops and a high degree of self-directed learning. Each full day workshop focuses on a specific topic, such as physical computing with ESP32 microcontrollers or image processing with OpenCV. Between workshops, students are encouraged to work on their projects, applying the concepts and techniques learned during the workshops. The course culminates in a final project where students (in pairs) showcase their skills by creating a small interactive game or immersive media experience that combines physical computing and camera image processing.</p>"},{"location":"administration/administration/#grading","title":"Grading","text":"<p>Grading is based on participation in workshops (35%), completion and quality of assignments (30%), and the final project (35%). Students are expected to actively engage in the learning process, collaborate with peers, and demonstrate their understanding of physical computing and image processing concepts through practical applications. The lecturers can provide feedback about grading and support throughout the course to help students succeed in their projects.</p>"},{"location":"administration/administration/#prerequisites","title":"Prerequisites","text":"<p>Participants should have a Github account and be familiar with Git version control. Some assignment tasks will require the use of Git for submission and collaboration via Github classrooms. If you do not have a Github account and do not want to create one, please contact the instructors for alternative arrangements.</p>"},{"location":"administration/experience/","title":"Share your experience","text":""},{"location":"administration/experience/#share-your-experience","title":"Share your experience","text":"<p>We want to start the course by sharing your prior experience with physical computing, microcontrollers, and programming. This will help us to understand your background and tailor the course content accordingly. We also want to hear about your expectations for the course.</p>"},{"location":"administration/experience/#two-truths-and-a-lie","title":"Two truths and a lie","text":"<p>Note down two true statements and one false statement about your expectations for this course or about your experience with physical computing, microcontrollers, or programming. (3 minutes)</p> <p>Combine all statements as you like, but ensure that only one of them is false.</p> <p>Share these statements with the group, and let others guess which one is the lie. You don't have to reveal which one is the lie.</p>"},{"location":"administration/experience/#protocol","title":"Protocol","text":"<ul> <li>I worked with Arduino at school</li> <li>I build a microcontroller at FSM to control a clock</li> <li>Microcontrollers as entry point to programming (x)</li> <li>I expect to build a game controller for project 4</li> <li>I connected a MC to a PC but only sends numbers</li> <li>I connnected a MC to a PC and it sends commands (x)</li> <li>I worked with sensors</li> <li>I have knowledge about high-voltage stuff</li> <li>I know how to connect microcontrollers mechanically</li> <li>Expect to use physical components in game engines in this course</li> <li>I expect to build a rocket in this course (x)</li> <li>I modified a microscope with an Arduino for 3D imaging</li> <li>You can pass the course even with difficulties in coding</li> <li>We build a robot that cooks Carbonara</li> <li>We build a controller ourselves.</li> </ul>"},{"location":"administration/experience/#links","title":"Links","text":"<p>John Carmack at NASA</p>"},{"location":"theory/Physical-Computing/","title":"What is Physical Computing?","text":""},{"location":"theory/Physical-Computing/#what-is-physical-computing","title":"What is Physical Computing?","text":"<ul> <li>Creates a connection between the physical world and the virtual world of a computer.</li> <li>The flow between physical and virtual world is enabled by the process of\u00a0transduction, the conversion of one form of energy into another.</li> <li>Focus on interactive systems by fusing software and hardware.</li> </ul> <p>For creating interactive systems in your projects you'll need to use transducers to convert between the physical energy and electrical energy used by the computer. A familiar transducer is a microphone: pressure waves are transformed to electrical voltage. Another familiar transducer are speakers: electrical voltage are transformed to pressure waves.</p> <p>Transducers are the eyes, ears, hands, legs, and mouth of any physical computing system.</p> <p>With physical computing you'll have the opportunity to express and or enhance your creativity with embodied interaction.</p>"},{"location":"theory/Physical-Computing/#what-products-result-from-the-application-of-physical-computing","title":"What products result from the application of physical computing?","text":"<ul> <li>Wearables</li> <li>Smart Home Applications</li> <li>Intelligent Toys</li> <li>Sensor Based Irrigation Systems</li> <li>Mood Lamps ...</li> </ul>"},{"location":"theory/Physical-Computing/#here-are-some-examples","title":"Here are some examples:","text":"<p>Brightness-controlled color-changing flower pot</p> <p>A collection of Arduino Project Examples</p>"},{"location":"theory/interaction/","title":"Interaction: Input, Output, and Processing","text":""},{"location":"theory/interaction/#interaction-input-output-and-processing","title":"Interaction: Input, Output, and Processing","text":"<p>Definition according to Chris Crawford (author and game programmer): \"an iterative process of listening, thinking, and speaking between two or more actors\". </p> <p>A physical project can be broken into down the same three stages: listening, thinking, speaking. In computer terms: input, processing, output.</p> <ul> <li>Input</li> <li>Output</li> </ul> <p>Signals here can be </p> <ul> <li>Analog </li> <li>Digital</li> </ul>"},{"location":"theory/interaction/#interaction","title":"Interaction","text":"<ul> <li>Serial </li> <li>Parallel</li> </ul>"},{"location":"theory/interaction/#input","title":"Input","text":""},{"location":"theory/interaction/#sensors-input-transducers","title":"Sensors (Input transducers)","text":"<ul> <li>Sense the world.</li> <li>Convert heat, light, motion, and sound into electrical energy.</li> </ul>"},{"location":"theory/interaction/#examples-ai-generated-verified","title":"Examples (AI generated, verified)","text":"Physical Quantity (Input) Conversion Input Transducer (Example) Heat (temperature) Converts heat \u2192 change in resistance or voltage Thermistor, Thermocouple Light Converts light intensity \u2192 change in resistance or current LDR (Light Dependent Resistor), Photodiode, Phototransistor Motion / Position Converts movement or position \u2192 electrical signal Switch, Potentiometer, Rotary encoder Sound (vibrations) Converts sound waves \u2192 varying voltage Microphone Pressure Converts pressure \u2192 change in resistance or voltage Strain gauge, Piezoelectric sensor, BMP sensor Magnetic field Converts magnetic field strength \u2192 voltage Hall effect sensor Humidity Converts moisture level \u2192 change in capacitance Capacitive humidity sensor Displacement / Stretch Converts mechanical displacement \u2192 voltage LVDT (Linear Variable Differential Transformer), FSR (force sensitive resistor) <p>Notes:</p> <ul> <li>Pick the sensor by asking \"what do I want to know?\" and where it will be used (indoors/outdoors, battery or mains).</li> <li>Simpler sensors are easier to start with, add more precise ones as needed.</li> </ul>"},{"location":"theory/interaction/#output","title":"Output","text":""},{"location":"theory/interaction/#actuators-output-transducers","title":"Actuators (output transducers)","text":"<ul> <li>Change the world.</li> <li>Convert electrical energy into various forms that the body can sense.</li> </ul>"},{"location":"theory/interaction/#examples-ai-generated-verified_1","title":"Examples (AI generated, verified)","text":"Electrical Input Conversion Actuator (Example) Electrical energy Converts electricity \u2192 rotational motion Electric motor Electrical energy Converts electricity \u2192 linear push/pull motion Solenoid Electrical signal Converts signal \u2192 mechanical switching Relay Electrical energy Converts electricity \u2192 heat Heater element Electrical energy Converts electricity \u2192 light Lamp, LED Electrical signal Converts signal \u2192 sound (air vibration) Buzzer, Speaker Electrical energy Converts electricity \u2192 precise mechanical displacement Piezoelectric actuator Electrical control signal Converts electricity \u2192 mechanical motion via fluid/air Hydraulic or pneumatic actuator <p>Notes:</p> <ul> <li>Choose an actuator by asking \"what do I want to move or change?\" and where it will be used (indoor/outdoor, sealed, etc.).</li> <li>Check required power, voltage and current; many actuators need drivers, and other electronic parts.</li> <li>Match force/torque, speed and travel/stroke to the task.</li> <li>Consider control method (on/off, analog) and whether position/force feedback is needed.</li> <li>Account for heat, noise, mechanical safety (stops, guards) and electrical isolation.</li> <li>Prefer modular and serviceable actuators for maintenance and replacement.</li> <li>For battery-powered systems, consider energy use and standby consumption.</li> </ul>"},{"location":"theory/interaction/#processing","title":"Processing","text":"<p>Input and output are the physical parts of physical computing. The third part is the programming part: </p> <ul> <li>Computer reads input.</li> <li>Makes decisions based on the changes it reads.</li> <li>Activate outputs or send messages to other computers.</li> </ul>"},{"location":"theory/processing/","title":"Processing: Microcontroller, Microprocessor","text":""},{"location":"theory/processing/#processing-microcontroller-microprocessor","title":"Processing: Microcontroller, Microprocessor","text":"<p>For processing we need a computer. Different purposes require different computers. E.g. your laptop has a different purposes than the one in your phone or the camera.</p>"},{"location":"theory/processing/#microcontroller","title":"Microcontroller","text":"<p>In physical computing very often a\u00a0microcontroller is used.</p> <ul> <li>Are optimized for control of physical input and output.</li> <li>Small, very simple and receives information through sensors, controls basic motors and sends information to other devices.</li> <li>Found in everything e.g. washing machines, light switches, keyboards and computer mice.</li> <li>Don't have an operating system, just run one program (that you will program onto the controller from a personal computer using a dedicated hardware programming device).</li> <li>Come in different layouts and sizes but need a so called development board to operate:<ul> <li>The Processor Itself</li> <li>Power Regulation Circuitry</li> <li>Hardware Programmer Connector</li> <li>Communications Interface Circuitry</li> </ul> </li> </ul>"},{"location":"theory/processing/#examples","title":"Examples:","text":""},{"location":"theory/processing/#esp32","title":"ESP32","text":"<p>This is a microcontroller with integrated Wi\u2011Fi and Bluetooth, designed for IoT and embedded applications. (Used also in this class)</p> <p>Here is a tutorial page dedicated to ESP32.</p>"},{"location":"theory/processing/#arduino-uno-development-board","title":"Arduino Uno (development board)","text":""},{"location":"theory/processing/#microprocessor","title":"Microprocessor","text":""},{"location":"theory/processing/#raspberry-pi","title":"Raspberry Pi","text":"<p>More powerful: Microprocessor</p> <ul> <li> <p>A computer.</p> </li> <li> <p>Needs periphery (RAM, memory).</p> </li> <li> <p>Runs an operating system.\u00a0</p> </li> <li> <p>Cost-effective and fully-fledged personal computer.</p> </li> </ul> <p>We will use it also in class embedded in a small driving robot.</p>"},{"location":"theory/processing/#pin-functions-of-microcontroller","title":"Pin Functions of Microcontroller","text":"<p>Microcontrollers can have between 6 and 60 pins:</p> <ul> <li>Attach power connections.</li> <li>Input and output connections.</li> <li>Communications connections. </li> </ul> <p>Every microcontroller has different configurations for its pins, and often one pin will have more than one function. </p> <p></p>"},{"location":"theory/processing/#esp32-pin-layers","title":"ESP32 Pin Layers","text":"Pin Layer Description What It Refers To ESP32-WROOM-32 Module pins The 38 physical pads on the metal-cased module itself These are directly connected to the ESP32 chip inside the module Development board pins The header pins (e.g., \u201cGPIO 21\u201d, \u201cVIN\u201d, \u201c3V3\u201d) on your DevKit These are mapped to the module pins, sometimes with naming differences or extra components in between because these are functional pin names (what they do) <p>Lets consider:</p> <p>| GPIO15|  ADC2_CH3 | TOUCH3 | HSPI_CS0 | RTC_GPIO13|</p> <p>Each part describes different internal functions of the same physical pin on the ESP32.</p> <p>GPIO15: digital pin number used in Arduino or ESP-IDF code.</p> <ul> <li>When you use <code>digitalWrite(15, HIGH)</code> you\u2019re toggling this pin.</li> <li>It\u2019s the logical pin identifier.</li> </ul> <p>ADC2_CH3</p> <ul> <li>This means the pin is connected to the Analog-to-Digital Converter 2, Channel 3.</li> </ul> <p>TOUCH3</p> <p>The ESP32 has capacitive touch sensors built into some GPIOs. </p> <ul> <li>TOUCH3 means this pin can act as touch sensor number 3.</li> </ul> <p>In Arduino, you can use it like:</p> <p><code>int touchValue = touchRead(T3);  // or touchRead(15)</code></p> <p>HSPI_CS0 (SPI = Serial Peripheral Interface)</p> <p>Use it when you connect e.g. to a display or other sensors.</p>"},{"location":"theory/processing/#references-for-pins","title":"References for pins","text":"<p>A reference to ESP32 pins you can find on this page. You can find more details generally on pins on this page.</p>"},{"location":"theory/references/","title":"References","text":"<p>The theory of the course is based on the book:</p> <p></p> <p>O\u0315'Sullivan, Dan; Igoe, Tom: Physical computing : Sensing and Controlling the Physical World with Computers, Boston, Mass. : Thompson, 2004</p> <p>Other references are noted along.</p>"},{"location":"tutorials/ESP32-01-FirstSteps/","title":"Working with ESP32 devices","text":""},{"location":"tutorials/ESP32-01-FirstSteps/#working-with-esp32-devices","title":"Working with ESP32 devices","text":""},{"location":"tutorials/ESP32-01-FirstSteps/#overview","title":"Overview","text":"<p>The ESP32 is a powerful microcontroller with built-in touch capabilities, making it ideal for physical computing projects. In this section, we will cover the basics of working with ESP32 devices, including setting up the development environment, programming the device, and interfacing with various input and output components.</p>"},{"location":"tutorials/ESP32-01-FirstSteps/#gather-the-hardware-components","title":"Gather the hardware components","text":"<ol> <li> <p>ESP32 Development Board</p> <p></p> </li> <li> <p>USB Cable (for programming and power)</p> <p></p> </li> <li> <p>Computer for programming the ESP32 and applications</p> </li> </ol>"},{"location":"tutorials/ESP32-01-FirstSteps/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<p>We want to program the ESP32 using the Arduino IDE. Therefore, we need to install the Arduino IDE and set it up for ESP32 development.</p>"},{"location":"tutorials/ESP32-01-FirstSteps/#installing-or-updating-the-arduino-ide","title":"Installing or Updating the Arduino IDE","text":"<ol> <li>Download the latest version of the Arduino IDE from the official Arduino website. Choose the version that matches your operating system (Windows, macOS, or Linux). This guide has been written using Arduino IDE version 2.3.6 on MacOS.</li> </ol>"},{"location":"tutorials/ESP32-01-FirstSteps/#installing-usb-to-serial-drivers","title":"Installing USB to Serial Drivers","text":"<p>Check if your board has a built-in USB to Serial converter. Most ESP32 boards use the CP210x or CH340 chip for USB to Serial communication. If your board uses one of these chips, you may need to install the appropriate drivers.</p> <p>Here is an image of the CP210x chip:</p> <p></p> <p>You can download the USB to Serial drivers from the Silicon Labs website: Silicon Labs USB to UART Bridge VCP Drivers. Choose the appropriate driver for your operating system (Windows, macOS, or Linux) and follow the installation instructions provided on the website. Note that under Windows the VCP driver worked better that the universal one.</p>"},{"location":"tutorials/ESP32-01-FirstSteps/#installing-the-esp32-board-package-in-arduino-ide","title":"Installing the ESP32 Board Package in Arduino IDE","text":"<ol> <li>Open the Arduino IDE.</li> <li>Go to <code>File</code> &gt; <code>Preferences</code> (on macOS, <code>Arduino</code> &gt; <code>Settings</code>).</li> <li> <p>In the \"Additional Boards Manager URLs\" field, add the following URL (if there are already URLs in the field, separate them with a comma):</p> <pre><code>https://dl.espressif.com/dl/package_esp32_index.json\n</code></pre> </li> <li> <p>Click \"OK\" to close the Preferences window.</p> </li> <li>Open the Boards Manager by going to <code>Tools</code> &gt; <code>Board</code> &gt; <code>Board Manager</code>.</li> <li>In the Boards Manager, search for \"ESP32\" and install the \"ESP32 by Espressif Systems\" package. When writing this guide, the latest version is 3.3.3.</li> </ol>"},{"location":"tutorials/ESP32-01-FirstSteps/#selecting-the-esp32-board-and-port","title":"Selecting the ESP32 Board and Port","text":"<p>After installing the ESP32 board package, use the \"Select board\" dropdown to choose your specific ESP32 board model from the list.</p> <ol> <li>For the ESP32-Wroom-32, select \"ESP32 Dev Board\".</li> <li>Select the serial port on the right hand side.</li> </ol> <p>On Windows it should look like:</p> <p></p> <p>Your IDE (MAC) after selection should now look similar to this:</p> <p></p> <p>It shows the selected board \"ESP32 Dev Module\" (blue rectangle) and the port \"/dev/cu.SLAB_USBtoUART\" (green rectangle; this may vary depending on your system). In the center you see the code editor where you can write your sketches. On the top left you find buttons (orange rectangle) to verify (check mark) and upload (right arrow) your code to the ESP32.</p> <p>Your IDE (Windows) after selection should look like:</p> <p></p> <p>Eventually, it is necessary to set the Baud rate to 115200. You can do this by going to <code>Tools</code> &gt; <code>Upload Speed</code> and selecting <code>115200</code>.</p>"},{"location":"tutorials/ESP32-01-FirstSteps/#writing-your-first-esp32-sketch-blink-the-on-board-led","title":"Writing Your First ESP32 Sketch: Blink the on-board LED","text":"<p>Edit the code editor to contain the following code:</p> <pre><code>int ledPin = 1; // the pin of the on-board LED\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT); // set pin 1 as output\n}\n\nvoid loop() {\n  digitalWrite(ledPin, HIGH); // sets pin to high voltage (ON)\n  delay(500); // wait half a second\n  digitalWrite(ledPin, LOW); // set pin to low voltag (OFF)\n  delay(500); // wait again\n}\n</code></pre> <p>This code will blink the on-board LED of the ESP32 every second. But first we need to verify and then upload the code to the ESP32. Directly after uploading the on-board LED should start blinking.</p> <p>Now you have successfully set up your development environment and programmed your ESP32 to blink an LED! You can now proceed to explore more complex projects and functionalities of the ESP32.</p>"},{"location":"tutorials/ESP32-01-FirstSteps/#control-questions","title":"Control questions","text":"<ul> <li>How can you modify the code to make the LED blink faster or slower?</li> <li>What happens if you unplug the ESP32 while the code is running? What do you observe when you plug it back in?</li> </ul>"},{"location":"tutorials/ESP32-02-OutputControls/","title":"Controlling a LED with the ESP32","text":""},{"location":"tutorials/ESP32-02-OutputControls/#controlling-a-led-with-the-esp32","title":"Controlling a LED with the ESP32","text":"<p>In this tutorial, we will learn how to control an external LED using the ESP32 microcontroller. We will connect an LED to one of the GPIO pins of the ESP32 and write a simple program to turn the LED on and off.</p>"},{"location":"tutorials/ESP32-02-OutputControls/#hardware-setup","title":"Hardware Setup","text":""},{"location":"tutorials/ESP32-02-OutputControls/#components-needed","title":"Components Needed","text":"<ol> <li>ESP32 Development Board</li> <li>USB Cable for programming the ESP32</li> <li>Computer with Arduino IDE installed</li> <li> <p>Breadboard and wires</p> <p></p> </li> <li> <p>Output components (we use an LED and therefore we need resistors)</p> <p></p> </li> </ol>"},{"location":"tutorials/ESP32-02-OutputControls/#wiring-the-led","title":"Wiring the LED","text":"<ol> <li>Connect the longer leg (anode) of the LED to a GPIO pin on the ESP32 (e.g., GPIO 18).</li> <li>Connect the shorter leg (cathode) of the LED to one end of a resistor (typically 220-330 ohms).</li> <li>Connect the other end of the resistor to the GND pin on the ESP32.</li> <li>Make sure all connections are secure.</li> </ol>"},{"location":"tutorials/ESP32-02-OutputControls/#programming-the-esp32","title":"Programming the ESP32","text":"<pre><code>// Define the GPIO pin where the LED is connected\nconst int ledPin = 18; // Change this to the pin you used\nvoid setup() {\n  // Initialize the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // Turn the LED on\n  digitalWrite(ledPin, HIGH);\n  delay(1000); // Wait for 1 second\n\n  // Turn the LED off\n  digitalWrite(ledPin, LOW);\n  delay(1000); // Wait for 1 second\n}\n</code></pre>"},{"location":"tutorials/ESP32-02-OutputControls/#uploading-the-code","title":"Uploading the Code","text":"<p>First, verify that the code is correct by clicking the \"Verify\" button (check mark) in the Arduino IDE. If there are no errors, click the \"Upload\" button (right arrow) to upload the code to the ESP32. You should see the update process logged in the IDE. After the upload is complete, the LED connected to the ESP32 should start blinking, turning on for one second and off for one second in a loop. You have successfully controlled an output device (LED) using the ESP32!</p>"},{"location":"tutorials/ESP32-02-OutputControls/#adding-debug-output-with-serial-monitor","title":"Adding debug output with Serial Monitor","text":"<p>Adjust the code above to include <code>Serial.begin(115200);</code> in the <code>setup()</code> function and <code>Serial.println(\"LED ON\");</code> and <code>Serial.println(\"LED OFF\");</code> in the <code>loop()</code> function. This will send debug messages to the Serial Monitor.</p> <p>You can also open the Serial Monitor (magnifying glass icon on the top right) to see the debug messages from the ESP32.</p>"},{"location":"tutorials/ESP32-02-OutputControls/#control-questions","title":"Control Questions","text":"<ul> <li>How can you modify the code to change the blink rate of the LED?</li> <li>Why is the internal LED blinking as well? What is it indicating?</li> <li>What would happen if you connected the LED without a resistor? (Do not try this!)</li> <li>How can you control multiple LEDs with the ESP32?</li> </ul>"},{"location":"tutorials/ESP32-03-TouchInput/","title":"Touch Input with the ESP32","text":""},{"location":"tutorials/ESP32-03-TouchInput/#touch-input-with-the-esp32","title":"Touch Input with the ESP32","text":"<p>In this tutorial, we will learn how to use the touch input capabilities of the ESP32 microcontroller. The ESP32 has several capacitive touch sensors built into its GPIO pins, allowing us to detect touch events without needing additional hardware.</p>"},{"location":"tutorials/ESP32-03-TouchInput/#hardware-setup","title":"Hardware Setup","text":""},{"location":"tutorials/ESP32-03-TouchInput/#components-needed","title":"Components Needed","text":"<ol> <li>ESP32 Development Board</li> <li>USB Cable for programming the ESP32</li> <li>Computer with Arduino IDE installed</li> <li> <p>Input components (we simply use wires as touch sensors)</p> <p></p> </li> </ol>"},{"location":"tutorials/ESP32-03-TouchInput/#wiring-the-touch-input","title":"Wiring the Touch Input","text":"<ol> <li>Connect one end of a wire to a touch-capable GPIO pin on the ESP32 (e.g., GPIO 2 aka Touch2 or T2).</li> <li>Be ready to touch the other end of the wire with your finger to simulate a touch event.</li> </ol>"},{"location":"tutorials/ESP32-03-TouchInput/#programming-the-esp32-for-touch-input","title":"Programming the ESP32 for Touch Input","text":"<pre><code>const int touchPin = T2; // Touch pin GPIO 2\nvoid setup() {\n  Serial.begin(115200); // Initialize serial communication for debugging\n  delay(1000);  // give me time to bring up serial monitor\n  //Optional: Set the threshold to 5% of the benchmark value. Only effective if threshold = 0.\n  touchSetDefaultThreshold(5);\n  touchAttachInterrupt(touchPin, onTouch, 0); // Attach touch interrupt using default threshold\n}\nvoid loop() {\n  // Main loop does nothing, waiting for touch events\n}\nvoid onTouch() {\n  Serial.println(\"Touch detected!\"); // Print message when touch is detected\n}\n</code></pre>"},{"location":"tutorials/ESP32-03-TouchInput/#uploading-the-code","title":"Uploading the Code","text":"<p>First, verify that the code is correct by clicking the \"Verify\" button (check mark) in the Arduino IDE. If there are no errors, click the \"Upload\" button (right arrow) to upload the code to the ESP32. You should see the update process logged in the IDE. After the upload is complete, open the Serial Monitor (magnifying glass icon on the top right) to see the debug messages from the ESP32.</p> <p>When you touch the wire connected to the touch-capable GPIO pin, you should see \"Touch detected!\" printed in the Serial Monitor. You have successfully used touch input with the ESP32!</p>"},{"location":"tutorials/ESP32-03-TouchInput/#control-questions","title":"Control Questions","text":"<ul> <li>What is the purpose of the <code>Serial.begin()</code> function in the setup?</li> <li>How can you change the touch pin to use a different GPIO pin?</li> <li>What happens if you change the threshold value in <code>touchSetDefaultThreshold()</code>?</li> <li>How can you modify the code to perform a different action when a touch is detected?</li> </ul>"},{"location":"tutorials/ESP32-04-TouchLED/","title":"Touch Input to control an LED with the ESP32","text":""},{"location":"tutorials/ESP32-04-TouchLED/#touch-input-to-control-an-led-with-the-esp32","title":"Touch Input to control an LED with the ESP32","text":"<p>In this tutorial, we will combine touch input and output control using the ESP32 microcontroller. We will use a touch-capable GPIO pin to detect touch events and control an LED based on those events.</p>"},{"location":"tutorials/ESP32-04-TouchLED/#hardware-setup","title":"Hardware Setup","text":""},{"location":"tutorials/ESP32-04-TouchLED/#components-needed","title":"Components Needed","text":"<ol> <li>ESP32 Development Board</li> <li>USB Cable for programming the ESP32</li> <li>Computer with Arduino IDE installed</li> <li>Input components (we simply use wires as touch sensors)</li> <li>Breadboard and wires</li> <li>Output components (we use an LED and therefore we need resistors)</li> </ol>"},{"location":"tutorials/ESP32-04-TouchLED/#wiring-everything-together","title":"Wiring everything together","text":"<p>Combine the wiring instructions from the previous two tutorials and note down which GPIO pins you are using for the touch input and the LED output.</p>"},{"location":"tutorials/ESP32-04-TouchLED/#programming-the-esp32","title":"Programming the ESP32","text":"<pre><code>// Define the GPIO pins where the LED is connected and the one for touch input\nconst int ledPin = X; // Change this to the pin you used\nconst int touchPin = X; // Change this to the pin you used\nbool LED_OFF = false; // set the initial value for the LED\n\nvoid setup() {\n  Serial.begin(115200); // Initialize serial communication for debugging\n  delay(1000);  // give me time to bring up serial monitor\n\n  //Optional: Set the threshold to 5% of the benchmark value. Only effective if threshold = 0.\n  touchSetDefaultThreshold(5);\n  touchAttachInterrupt(touchPin, onTouch, 0); // Attach touch interrupt using default threshold\n\n  // Initialize the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n  if (LED_OFF) {\n    digitalWrite(ledPin, LOW); // turn LED off initially\n  } else {\n    digitalWrite(ledPin, HIGH); // turn LED on initially\n  }\n\n}\n\nvoid loop() {\n  // do nothing\n}\n\nvoid onTouch() {\n  Serial.println(\"Touch detected!\"); // Print message when touch is detected\n  toggleLED();\n}\n\nvoid toggleLED() {\n\n  if (LED_OFF) {\n    // Turn the LED on\n    digitalWrite(ledPin, HIGH);\n    LED_OFF = false;\n  } else {\n    // Turn the LED off\n    digitalWrite(ledPin, LOW);\n    LED_OFF = true;\n  }\n}\n</code></pre>"},{"location":"tutorials/ESP32-04-TouchLED/#uploading-the-code","title":"Uploading the Code","text":"<p>First, verify that the code is correct by clicking the \"Verify\" button (check mark) in the Arduino IDE. If there are no errors, click the \"Upload\" button (right arrow) to upload the code to the ESP32. You should see the update process logged in the IDE. After the upload is complete, open the Serial Monitor (magnifying glass icon on the top right) to see the debug messages from the ESP32.</p> <p>What happens when you touch the wire connected to the touch-capable GPIO pin? Does the LED connected to the ESP32 toggle its state (on to off or off to on) each time you touch the wire?</p>"},{"location":"tutorials/ESP32-04-TouchLED/#next-steps","title":"Next Steps","text":"<ul> <li>How can we modify the code so that we can use the touch input like a switch? (i.e., touch once to turn the LED on, touch again to turn it off)</li> </ul>"},{"location":"tutorials/ESP32-05-TouchCapture/","title":"Touch Input to capture images","text":""},{"location":"tutorials/ESP32-05-TouchCapture/#touch-input-to-capture-images","title":"Touch Input to capture images","text":"<p>In this tutorial, we will combine touch input and an OpenCV application running on a computer to capture images when the ESP32 touch sensor is activated.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#hardware-setup","title":"Hardware Setup","text":""},{"location":"tutorials/ESP32-05-TouchCapture/#components-needed","title":"Components Needed","text":"<ol> <li>ESP32 Development Board</li> <li>USB Cable for programming the ESP32</li> <li>Computer with Arduino IDE and Python environment (alternatively use JavaScript) installed</li> <li>Input components (we simply use wires as touch sensors)</li> <li>Breadboard and wires</li> <li>Optional: Output components (we use an LED and therefore we need resistors)</li> </ol>"},{"location":"tutorials/ESP32-05-TouchCapture/#wiring-everything-together","title":"Wiring everything together","text":"<p>We only need to wire the touch input as described in the Touch Input tutorial. Note down which GPIO pin you are using for the touch input.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#programming-the-esp32","title":"Programming the ESP32","text":"<p>Define the GPIO pin where the touch sensor is connected:</p> <pre><code>const int capturePin = T2; // Change this to the pin you used\n</code></pre> <p>Add the following code to your ESP32 sketch in the setup function to attach the touch interrupt to the capture pin:</p> <pre><code>touchAttachInterrupt(capturePin, onCapture, 0);\n</code></pre> <p>Then add the following function to handle the touch event and send a capture signal via Serial:</p> <pre><code>void onCapture() {\n  Serial.print(\"CAPTURE\"); // send capture signal\n}\n</code></pre>"},{"location":"tutorials/ESP32-05-TouchCapture/#uploading-the-code","title":"Uploading the Code","text":"<p>First, verify that the code is correct by clicking the \"Verify\" button (check mark) in the Arduino IDE. If there are no errors, click the \"Upload\" button (right arrow) to upload the code to the ESP32. You should see the update process logged in the IDE. After the upload is complete, open the Serial Monitor (magnifying glass icon on the top right) to see the debug messages from the ESP32.</p> <p>Stop the Serial Monitor after verifying that the ESP32 is running correctly.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#setting-up-the-computer-application","title":"Setting up the Computer Application","text":"<p>To capture images when the ESP32 touch sensor is activated, we will use a Python script that listens to the Serial port for the \"CAPTURE\" signal and then captures an image using OpenCV.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#python-solution","title":"Python solution","text":"<p>Make sure you have Python installed on your computer.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#creating-and-activating-a-virtual-environment","title":"Creating and activating a Virtual Environment","text":"<p>It is highly recommended to create a virtual environment for this project. You can do this using the following commands:</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#macoslinux","title":"MacOS/Linux","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  \n</code></pre>"},{"location":"tutorials/ESP32-05-TouchCapture/#windows-powershell","title":"Windows (PowerShell)","text":"<pre><code>python -m venv .venv\n.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>Note On Microsoft Windows, it may be required to enable the <code>Activate.ps1</code> script by setting the execution policy for the user. You can do this by issuing the following PowerShell command:</p> <pre><code>PS C:\\&gt; Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n</code></pre> <p>See About Execution Policies for more information.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#installing-required-packages","title":"Installing Required Packages","text":"<p>Make sure your computer is connected to the Internet. Install the required packages using pip:</p> <pre><code>pip install pyserial opencv-python\n</code></pre>"},{"location":"tutorials/ESP32-05-TouchCapture/#python-script","title":"Python Script","text":"<p>Use the Python script touch_capture.py provided in the code folder of this course repository and copy it to your working directory.</p> <p>Run the script using the following command:</p> <pre><code>python touch_capture.py\n</code></pre> <p>This script will listen to the Serial port for the \"CAPTURE\" signal from the ESP32 and capture an image using OpenCV when the signal is received. The captured images will be saved in the same directory as the script.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#javascript-solution","title":"JavaScript solution","text":"<p>Download the JavaScript code touch_capture.js.zip provided in the code folder of this course repository, copy it to your working directory and start it with a local server. Or test it online here.</p>"},{"location":"tutorials/ESP32-05-TouchCapture/#next-steps","title":"Next Steps","text":"<ul> <li>Try to understand the Python or JavaScript code and modify it to change some details. We will cover this in more detail in later sections.</li> <li>Think about how to extend this setup to use other trigger mechanisms or to add more features to the image capture application.</li> </ul>"},{"location":"tutorials/ESP32-PinSpec/","title":"ESP32 Pin Specifications","text":""},{"location":"tutorials/ESP32-PinSpec/#esp32-pin-specifications","title":"ESP32 Pin Specifications","text":"<p>The ESP32 microcontroller has a variety of pins that serve different functions. Below is a summary of the key pin specifications:</p> <p></p> <p>Source: AZ-Delivery ESP32 DevKitC V2 manual</p>"},{"location":"tutorials/GoPiGo/","title":"Introduction to GoPiGo","text":""},{"location":"tutorials/GoPiGo/#introduction-to-gopigo","title":"Introduction to GoPiGo","text":"<p>What Is GoPiGo?</p> <ul> <li>A small mobile robot platform that attaches to a Raspberry Pi.</li> <li>Designed for learning robotics, sensors, and programming with Python.</li> </ul> <p>Hardware Overview</p> <ul> <li>Base chassis with motors, wheels, and frame.</li> <li>Raspberry Pi mounted on top (user-supplied).</li> <li>GoPiGo control board that connects to the Pi GPIO header.</li> <li>Battery pack to power motors.</li> </ul> <p>Full Hardware Specs</p> <p>Simple Python Example</p> <pre><code># Example: drive_demo.py\nimport easygopigo3 as easy\nimport time\norienteer = easy.EasyGoPiGo3()\norienteer.drive_cm(40)\n</code></pre> <p>Live Demo:</p> <ul> <li>Power on the GoPiGo (battery pack or power supply).</li> <li> <p>On your laptop, open your Wi-Fi list.</p> </li> <li> <p>Look for a network like GoPiGo.</p> </li> <li> <p>Connect to that network (no internet access needed).</p> </li> </ul> <p>Once connected, open your browser and go to:  http://mygopigo.com/python</p> <p>You should see the GoPiGo control panel/Jupyter environment.</p> <p>The instructions for your first project you can find here:</p> <p>Orienteer</p> <p>GoPiGo API Documentation</p>"},{"location":"tutorials/OpenCV/","title":"OpenCV Tutorial","text":""},{"location":"tutorials/OpenCV/#opencv-tutorial","title":"OpenCV Tutorial","text":""},{"location":"tutorials/OpenCV/#introduction","title":"Introduction","text":"<p>OpenCV (Open Source Computer Vision Library) is an open-source computer vision and machine learning software library. It contains more than 2500 optimized algorithms for a wide range of computer vision tasks, including object detection, image processing, and video analysis. It is available since 1999 and has become one of the most popular libraries in the field of computer vision.</p>"},{"location":"tutorials/OpenCV/#getting-started","title":"Getting Started","text":"<p>The tutorials are provided as Jupyter Notebooks. To get started, ensure you have the following prerequisites installed:</p> <ul> <li>Python 3.7 or higher</li> <li>Jupyter Notebook</li> <li>OpenCV library</li> </ul>"},{"location":"tutorials/OpenCV/#notebooks","title":"Notebooks","text":"<p>The following notebooks will guide you through various OpenCV functionalities:</p> <ul> <li>01 OpenCV Basics: Introduction to OpenCV, image loading, and basic operations including color space conversions and webcam access.</li> <li>02 OpenCV Image Transformations: Image translation, rotation, resizing, and perspective transformations.</li> <li>03 OpenCV Camera Calibration: Camera calibration with chessboard patterns, distortion correction, and real-world measurements.</li> <li>tbc</li> </ul>"},{"location":"tutorials/OpenCV/#additional-resources","title":"Additional Resources","text":"<p>Image processing theory: Slides</p>"},{"location":"tutorials/SerialInterfaces/","title":"List of serial connection options","text":""},{"location":"tutorials/SerialInterfaces/#list-of-serial-connection-options","title":"List of serial connection options","text":"<p>There are several options for serial communication with the ESP32. Here are the tested ones:</p> <ul> <li>JavaScript with the Web Serial API as used in the Photobooth Application</li> <li>Python with the <code>pyserial</code> library as used in the Photobooth Application</li> </ul> <p>Other options include:</p> <ul> <li>JavaScript in p5.js with the p5.serialport library</li> <li>Scratch with ScratchSerialExtension</li> <li>Godot Engine with the Godot Serial Plugin</li> </ul> <p>Feel free to explore these options and choose the one that best fits your project needs!</p>"},{"location":"tutorials/code/javascript/readme/","title":"JavaScript sample application for ESP32 Serial Communication","text":""},{"location":"tutorials/code/javascript/readme/#javascript-sample-application-for-esp32-serial-communication","title":"JavaScript sample application for ESP32 Serial Communication","text":""},{"location":"tutorials/code/javascript/readme/#photobooth-application","title":"Photobooth Application","text":"<p>This is a simple JavaScript application that communicates with an ESP32 microcontroller over a serial connection. The application allows users to control a photobooth setup by sending commands to the ESP32. See the Touch Input to capture images tutorial for more details.</p>"},{"location":"tutorials/code/python/readme/","title":"Python sample application for ESP32 Serial Communication","text":""},{"location":"tutorials/code/python/readme/#python-sample-application-for-esp32-serial-communication","title":"Python sample application for ESP32 Serial Communication","text":""},{"location":"tutorials/code/python/readme/#photobooth-application","title":"Photobooth Application","text":"<p>This is a simple Python application that communicates with an ESP32 microcontroller over a serial connection. The webcam access and image processing is done with OpenCV. The application allows users to control a photobooth setup by sending commands to the ESP32. See the Touch Input to capture images tutorial for more details.</p>"}]}